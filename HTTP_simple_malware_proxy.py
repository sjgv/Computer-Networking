'''
A simple concurrent proxy
Invariants
          : Server must send request in relative mode
Written by Salvador Gutierrez
u1166606 
'''

import socket
import sys
import threading
import hashlib
import json
import datetime
from _thread import *


'''
returns 1 if in Absolute Mode
returns 2 if in Relative Mode
else returns error
'''
def validate(connection, lines):
    #line zero must have METHOD URI VERSION
    try:
        elements = lines[0].split()
        version = elements[2] 
    except:
        return b'400 Bad Request\r\n'
    if elements[0] != "GET":
        return b'501 Not Implemented\r\n'
    if "HTTP/" not in version:
        return b'400 Bad Request\r\n'
    #it's -2 because we are suppossed to get 2 \r\n\r\n which are "", "" at the end
    for i in range(1,len(lines)-2):
        if ':' not in lines[i].split()[0]:
            return b'400 Bad Request\r\n'
    if "http://" not in elements[1]:
        #must be in relative mode
        try:
            parts = lines[1].split()
            if "Host:" in parts[0] and len(parts[1]) > 0:
                return 2
            else:
                return b'400 Bad Request\r\n'
        except:
            return b'400 Bad Request\r\n'
    else:
        return 1

'''
Formats request to be in relative mode
'''
def formatLines_relative(lines):
    #Must ensure Host: is part of header for method reroute
    elements_zero = lines[0].split()
    elements_one = lines[1].split()
    host = elements_one[1]
    msg = "GET" + " " + elements_zero[1] + " " + elements_zero[2].strip() + "\r\n"
    msg += "Host:" + " " + host + "\r\n"
    counter = 0
    for line in lines:
        if counter == 0 or counter == 1:
            continue
        if line[:10] == "Connection":
            msg += "Connection: close\r\n"
        if line[:10] == "Accept-Enc":
            msg += "Accept-Encoding: identity\r\n"
        else:
            msg += line + "\r\n"
        counter += 1
    if "\r\n\r\n" not in msg:
        msg += "\r\n\r\n"
    return [msg.encode(), host]


'''
Takes a request in absolute mode
Returns msg in relative mode
'''
def formatLines(lines):
    #Must ensure Host: is part of header for method reroute
    elements = lines[0].split()
    stripped_host = elements[1].replace("http://","")
    #host doesn't include last slash
    host = stripped_host[:stripped_host.index('/')]
    #relative does begin with slash
    relative_host = stripped_host[stripped_host.index('/'):]
    msg = "GET" + " " + relative_host + " " + elements[2].strip() + "\r\n"
    msg += "Host:" + " " + host + "\r\n"
    counter = 0
    for line in lines:
        if counter == 0 or counter == 1:
            continue
        if line[:10] == "Connection":
            msg += "Connection: close\r\n"
        if line[:10] == "Accept-Enc":
            msg += "Accept-Encoding: identity\r\n"
        else:
            msg += line + "\r\n"
        counter += 1
    if "\r\n\r\n" not in msg:
        msg += "\r\n\r\n"
    return [msg.encode(), host]


'''
input: HTTP Request, Host str
output: HTTP response in bytes
'''
def reroute(bites, hostStr):
    if ':' in hostStr:
        port = hostStr[hostStr.index(':')+1:]
        hostpart = hostStr[:hostStr.index(':')]
        host = (hostpart, port)
    else:
        host = (hostStr, 80)
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(host)
        s.sendall(bites)
        buff = b''
        while True:
            data = s.recv(1024)
            if data:
                buff += data
                data = ''
            else:
                s.close()
                break
    except:
        buff = b'404 resource not found'
    return buff

'''
input: HTTP response in bytes
output: transformed HTTP response in bytes
'''
def transform(response):
    data = response.decode()
    data = data.splitlines()
    nu_msg = ""
    for line in data:
        if "simple" in line or "Simple" in line:
            line = line.replace("Simple", "Silly")
            line = line.replace("simple", "silly")
        nu_msg += line+'\r\n'
    return nu_msg.encode()

'''
input: HTTP response in bytes
output: (md5 digest, HTTP response in bytes) 
'''
def getBytesDigest(response):
    idx = response.find(b'\r\n\r\n')
    cs4480_idx = response.find(b'CS4480')
    #check if it has the cs4480 prefix
    if cs4480_idx != -1:
        m = hashlib.md5(response[cs4480_idx+6:])
        return (m.hexdigest(), response[cs4480_idx+6:])
    else:
        m = hashlib.md5(response[idx+4:])
        return (m.hexdigest(), response[idx+4:])


'''
Checks if HTTP response is a web-page or not
NEEDS: maybe more specific for 'application' type
'''
def checkIfBinary(response):
    #print("IN BINARY:",response[:500])
    lines = response.splitlines()
    for line in lines:
        if b'Content-Type:' in line:
            parts = line.split()
            if b'bytes' in parts[1] or b'application' in parts[1]:
                return 1
    return 0


'''
Creates HTTP GET request
output: bytes
'''
def makeGet(apikey, digest):
    msg = "GET http://www.virustotal.com/vtapi/v2/file/report?apikey={}&resource={} HTTP/1.1\r\n".format(apikey, digest)
    msg += "Host: www.virustotal.com\r\n"
    msg += "Connection: close\r\n"
    msg += "Accept-Encoding: identity\r\n"
    msg += "\r\n\r\n"
    return msg.encode()

'''
Sends VT scan request and receives response
'''
def getVTReport(apikey,digest):
    hostNport = ("www.virustotal.com", 80)
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(hostNport)
        bites = makeGet(apikey,digest)
        s.sendall(bites)
        buff = b''
        while True:
            data = s.recv(1024)
            if data:
                buff += data
                data = ''
            else:
                break
    except:
        buff = b'VT NOT WORK'
    return buff

'''
input: HTTP response
output: Body of HTTP response
'''
def stripHeader(httpres):
    lines = httpres.splitlines()
    for i in range(0,len(lines)):
        if lines[i] == b'':
            return lines[i+1]
            
'''
Returns malware status + body
'''
def isMalware(jres, bytez):
    d = json.loads(jres)
    print(d)
    try:
        rc = int(d['response_code'])
        #unknown
        if rc == 0:
            res = okResponse("bytes",bytez)
            return (0, res)
        elif rc == 1:
            p = int(d['positives'])
            if p > 0:
                msg = malware_response(d['md5'], d['positives'],d['scan_date'], "Bkav", d['permalink'])
                res = okResponse("text/html", msg)
                return (1, res)
            else:
                res = okResponse("bytes",bytez)
                return (0, res)
                
    except:
        print("EXCEPTION")
        res = okResponse("text/html","ERROR")
        return (0, res)


'''
Creates a generic OK 200 response 
with the body_type and body provided
'''    
def okResponse(body_type, body):
    d = datetime.datetime.now()
    msg = "HTTP/1.1 200 OK\r\nDate: {}\r\nContent-Type: {}\r\nConnection: Closed\r\n\r\n\r\n{}".format(d, body_type,body)
    return msg.encode()


'''
Creates an HTML file with the fields provided below
'''
def malware_response(md5, positives, scan_date, first_id, permalink):
    s = '''<html>
    <body>
    <h1>The File you requested appears to contain Malware.</h2>
    <h2>Information:</h2>
    <ul>
    <li>MD5 Hash: {}</li>
    <li>Positives: {}</li>
    <li>Scan Date: {}</li>
    <li>First Scan ID: {}</li>
    </ul>
    <p>Thanks to VirusTotal for this information.</p>
    <p>For more information see <a href="{}">Virus Total Permanent Link</a></p>
    </body>
    </html>'''.format(md5, positives, scan_date, first_id, permalink)
    return s


'''
Handles all logic for a specific client
'''
def conn(connection,apikey):
    print("Started conn on thread")
    try:
        while True:
            data = connection.recv(4096)
            print("D",data)
            if data:
                msg = data.decode()
                lines = msg.splitlines()
                #results either trigger response or are response 
                res = validate(connection, lines)
                #Case: absolute mode
                print("R:",res)
                if res == 1:
                    bites = formatLines(lines)               #returns byte object
                    response = reroute(bites[0], bites[1])   #returns resource
                    print("RESP:", response[:500])
                    isApp = checkIfBinary(response)
                    if isApp == 1:
                        digest_bytes = getBytesDigest(response)
                        #### Use to test other Malware ###
                        #m = "2d75cc1bf8e57872781f9cd04a529256"
                        #httpres = getVTReport(apikey, m)
                        httpres = getVTReport(apikey, digest_bytes[0])
                        jres = stripHeader(httpres)
                        malware = isMalware(jres, digest_bytes[1])
                        connection.sendall(malware[1])
                    else:
                        transformed = transform(response)
                        connection.sendall(transformed)
                #Case relative mode:
                elif res == 2:
                    bites = formatLines_relative(lines)       #returns byte object
                    response = reroute(bites[0], bites[1])    #returns resource
                    isApp = checkIfBinary(response)
                    if isApp == 1:
                        digest_bytes = getBytesDigest(response)
                        httpres = getVTReport(apikey, digest_bytes[0])
                        jres = stripHeader(httpres)
                        malware = isMalware(jres, digest_bytes[1])
                        connection.sendall(malware[1])
                    else:
                        transformed = transform(response)
                        connection.sendall(transformed)
                #Error
                else:
                    print("ERROR")
                    connection.sendall(res)
                    break
            if msg.strip() == "bye":
                break
            else:
                break
    except:
        print("IN EXCEPT")
    finally:
        connection.close()

def main():
    '''
    The gist of a multiclient server is:
    1)Create a socket with the appropriate parameters (IPv4, TCP)
    2)Bind the socket to the server
    3)Start listening with that socket
    4)In a loop, accept connections through the socket that is listening
    5)On a new thread, use client connection established to do whatever
    '''
    if len(sys.argv) < 3:
        print("Incorrect number of arguments, please specify port number and/or key")
        exit()
    try:
        port = int(sys.argv[1])
        apikey = sys.argv[2]
    except:
        print("Couldn't convert port to an int")
        exit()
        
    #Create a TCP socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    #Bind socket to port
    server_addy = ('127.0.0.1', port)
    s.bind(server_addy)
    #Listen for incoming connection
    s.listen() #can specify a number of backlog connections before refusing new conns
    print("Listening to server @ %s on port %d" % (server_addy[0], server_addy[1]))
    #Start event loop
    while True:
        connection, client_addy = s.accept()
        start_new_thread(conn, (connection,apikey))
    s.close()



if __name__=="__main__":
    main()
